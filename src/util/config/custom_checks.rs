//! [CustomChecksOpt] trait for getting expected counter values to compare against the data.`
//! [CustomChecks] struct generated by deserializing TOML with expected counter values.
use std::path::PathBuf;

use macros::field_to_toml_string;
use serde_derive::{Deserialize, Serialize};
/// Module containing macros related to the custom checks.
pub mod macros {
    #[macro_export]
    /// Macro to generate a TOML string from a struct field with the following structure:
    /// * a commented out descriptive line.
    /// * a commented out example value & type line.
    /// * If the field values is `Some`
    ///    * a newline with the field in TOML format.
    /// * else
    ///   * a newline with a commented out TOML field with the field name and a the placeholder value: `(uncomment and set to enable)`.
    /// # Example
    /// ```
    /// # use fastpasta::util::config::custom_checks::macros::field_to_toml_string;
    /// let toml_string = field_to_toml_string!(
    ///     "Number of CRU Data Packets expected in the data.",
    ///     "Example value: 20 [type: u32]",
    ///     cdps,
    ///     Some(1)
    /// );
    /// assert_eq!(
    ///    toml_string,
    ///   "# Number of CRU Data Packets expected in the data.\
    ///  \n# Example value: 20 [type: u32]\
    ///  \ncdps = 1\
    ///  \n"
    /// );
    /// ```

    macro_rules! field_to_toml_string {
        ($comment:expr, $example:expr, $field_name:ident, $field_value:expr) => {
            if let Some(value) = $field_value {
                format!(
                    "# {comment}\n# {example}\n{field_name} = {value}\n",
                    comment = $comment,
                    example = $example,
                    field_name = stringify!($field_name),
                    value = value
                )
            } else {
                format!(
                    "# {comment}\n# {example}\n#{field_name} = (uncomment and set to enable)\n",
                    comment = $comment,
                    example = $example,
                    field_name = stringify!($field_name)
                )
            }
        };
    }
    pub use field_to_toml_string;
}

/// Trait for the configuration of various expected counters in the data.
pub trait CustomChecksOpt {
    /// Returns if any custom checks are enabled.
    fn custom_checks_enabled(&self) -> bool {
        self.cdps().is_some() || self.triggers_pht().is_some()
    }

    /// Returns if the option to generate a TOML file with default custom checks is enabled.
    fn generate_custom_checks_toml_enabled(&self) -> bool;

    /// Get the custom checks from a TOML file returning a [CustomChecks] instance.
    fn custom_checks_from_path(&self, toml_path: &PathBuf) -> CustomChecks {
        let toml = std::fs::read_to_string(toml_path).expect("Failed to read TOML file");
        toml::from_str(&toml).expect("Failed to parse TOML")
    }

    /// Write a [CustomChecks] instance to a TOML file in the current directory.
    fn generate_custom_checks_toml(&self) {
        let toml = CustomChecks::default().to_string_pretty();
        std::fs::write("custom_checks.toml", toml).expect("Failed to write TOML file");
    }

    /// Get the number of CDPS expected in the data, if it is set.
    fn cdps(&self) -> Option<u32>;

    /// Get the number of sent Triggers expected in the data, if it is set.
    fn triggers_pht(&self) -> Option<u32>;
}

impl<T> CustomChecksOpt for &T
where
    T: CustomChecksOpt,
{
    fn custom_checks_enabled(&self) -> bool {
        (*self).custom_checks_enabled()
    }

    fn generate_custom_checks_toml_enabled(&self) -> bool {
        (*self).generate_custom_checks_toml_enabled()
    }

    fn cdps(&self) -> Option<u32> {
        (*self).cdps()
    }

    fn triggers_pht(&self) -> Option<u32> {
        (*self).triggers_pht()
    }
}

impl<T> CustomChecksOpt for Box<T>
where
    T: CustomChecksOpt,
{
    fn custom_checks_enabled(&self) -> bool {
        (**self).custom_checks_enabled()
    }

    fn generate_custom_checks_toml_enabled(&self) -> bool {
        (**self).generate_custom_checks_toml_enabled()
    }

    fn cdps(&self) -> Option<u32> {
        (**self).cdps()
    }

    fn triggers_pht(&self) -> Option<u32> {
        (**self).triggers_pht()
    }
}

impl<T> CustomChecksOpt for std::sync::Arc<T>
where
    T: CustomChecksOpt,
{
    fn custom_checks_enabled(&self) -> bool {
        (**self).custom_checks_enabled()
    }

    fn generate_custom_checks_toml_enabled(&self) -> bool {
        (**self).generate_custom_checks_toml_enabled()
    }

    fn cdps(&self) -> Option<u32> {
        (**self).cdps()
    }

    fn triggers_pht(&self) -> Option<u32> {
        (**self).triggers_pht()
    }
}

/// Struct for the configuration of various expected counters in the data.
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct CustomChecks {
    counter_checks: Option<Counters>,
}

impl CustomChecks {
    /// Generate a TOML string from a [CustomChecks] instance.
    pub fn to_string_pretty(&self) -> String {
        if let Some(counters) = &self.counter_checks {
            counters.to_toml_string_pretty()
        } else {
            Counters::to_toml_string_pretty(&Counters::default())
        }
    }

    /// Get the number of CDPS expected in the data, if it is set.
    pub fn cdps(&self) -> Option<u32> {
        if let Some(counter_checks) = &self.counter_checks {
            counter_checks.cdps
        } else {
            None
        }
    }

    /// Get the number of sent Triggers expected in the data, if it is set.
    pub fn triggers_pht(&self) -> Option<u32> {
        if let Some(counter_checks) = &self.counter_checks {
            counter_checks.triggers_pht
        } else {
            None
        }
    }
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
struct Counters {
    cdps: Option<u32>,
    triggers_pht: Option<u32>,
}

impl Counters {
    fn to_toml_string_pretty(&self) -> String {
        let mut toml = String::from("[counter_checks]\n");

        toml.push_str(&field_to_toml_string!(
            "Number of CRU Data Packets expected in the data",
            "Example value: 20 [type: u32]",
            cdps,
            self.cdps
        ));

        toml.push_str(&field_to_toml_string!(
            "Number of Physics (PhT) Triggers expected in the data",
            "Example value: 20 [type: u32]",
            triggers_pht,
            self.triggers_pht
        ));

        toml
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use pretty_assertions::assert_eq;
    use temp_dir::TempDir;

    #[test]
    fn test_serialize() {
        let counters = CustomChecks {
            counter_checks: Some(Counters {
                cdps: Some(1),
                triggers_pht: None,
            }),
        };

        let toml = counters.to_string_pretty();
        println!("{toml}");
        assert_eq!(
            toml,
            r#"[counter_checks]
# Number of CRU Data Packets expected in the data
# Example value: 20 [type: u32]
cdps = 1
# Number of Physics (PhT) Triggers expected in the data
# Example value: 20 [type: u32]
#triggers_pht = (uncomment and set to enable)
"#
        );
    }

    #[test]
    fn test_deserialize() {
        let toml = r#"[counter_checks]
        # Number of CRU Data Packets expected in the data
        cdps = 1
        # Number of Physics (PhT) Triggers expected in the data.
        # triggers_pht = null
        "#;
        let counters: CustomChecks = toml::from_str(toml).unwrap();
        println!("{:#?}", counters);
        assert_eq!(counters.cdps(), Some(1));
        assert_eq!(counters.triggers_pht(), None);
    }

    #[test]
    fn test_generate_toml() {
        let counters_toml = CustomChecks::default().to_string_pretty();
        println!("{counters_toml}");
        assert_eq!(
            counters_toml,
            r#"[counter_checks]
# Number of CRU Data Packets expected in the data
# Example value: 20 [type: u32]
#cdps = (uncomment and set to enable)
# Number of Physics (PhT) Triggers expected in the data
# Example value: 20 [type: u32]
#triggers_pht = (uncomment and set to enable)
"#
        );
    }

    #[test]
    fn test_write_toml_to_file() {
        let counters = CustomChecks::default();
        let toml = counters.to_string_pretty();

        let tmp_dir = TempDir::new().unwrap();
        let toml_file = tmp_dir.child("counters.toml");
        std::fs::write(&toml_file, &toml).unwrap();

        assert_eq!(std::fs::read_to_string(toml_file).unwrap(), toml);
    }

    #[test]
    fn test_read_toml_from_file() {
        let counters = CustomChecks::default();
        let toml = counters.to_string_pretty();
        println!("toml string:\n{toml}");
        let tmp_dir = TempDir::new().unwrap();
        let toml_file = tmp_dir.child("counters.toml");
        std::fs::write(&toml_file, &toml).unwrap();
        let toml = std::fs::read_to_string(toml_file).expect("Failed to read TOML file");
        let custom_checks_from_toml: CustomChecks =
            toml::from_str(&toml).expect("Failed to parse TOML");

        println!("Struct from toml file: {:?}", custom_checks_from_toml);
        assert_eq!(custom_checks_from_toml.cdps(), None);
        assert_eq!(custom_checks_from_toml.triggers_pht(), None);
    }

    #[test]
    fn test_write_toml_to_file_trait() {
        let mock_config = crate::util::lib::test_util::MockConfig::default();
        mock_config.generate_custom_checks_toml();
        // Cleanup
        std::fs::remove_file("custom_checks.toml").unwrap();
    }
}
