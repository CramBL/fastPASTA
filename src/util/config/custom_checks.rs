//! [CustomChecksOpt] trait for getting expected counter values to compare against the data.`
//! [CustomChecks] struct generated by deserializing TOML with expected counter values.
use serde_derive::{Deserialize, Serialize};
use std::path::PathBuf;
use toml_macro::TomlConfig;
use toml_macro_derive::TomlConfig;
/// Module containing macros related to the custom checks.
pub mod macros {
    #[macro_export]
    /// Macro to generate a TOML string from a struct field with the following structure:
    /// * a commented out descriptive line.
    /// * a commented out example value & type line.
    /// * If the field values is `Some`
    ///    * a newline with the field in TOML format.
    /// * else
    ///   * a newline with a commented out TOML field with the field name and a the placeholder value: `(uncomment and set to enable)`.
    /// # Example
    /// ```
    /// # use fastpasta::util::config::custom_checks::macros::field_to_toml_string;
    /// let toml_string = field_to_toml_string!(
    ///     "Number of CRU Data Packets expected in the data.",
    ///     "Example value: 20 [type: u32]",
    ///     cdps,
    ///     Some(1)
    /// );
    /// assert_eq!(
    ///    toml_string,
    ///   "# Number of CRU Data Packets expected in the data.\
    ///  \n# Example value: 20 [type: u32]\
    ///  \ncdps = 1\
    ///  \n"
    /// );
    /// ```

    macro_rules! field_to_toml_string {
        ($comment:expr, $example:expr, $field_name:ident, $field_value:expr) => {
            if let Some(value) = $field_value {
                format!(
                    "# {comment}\n# {example}\n{field_name} = {value}\n",
                    comment = $comment,
                    example = $example,
                    field_name = stringify!($field_name),
                    value = value
                )
            } else {
                format!(
                    "# {comment}\n# {example}\n#{field_name} = (uncomment and set to enable)\n",
                    comment = $comment,
                    example = $example,
                    field_name = stringify!($field_name)
                )
            }
        };
    }
    pub use field_to_toml_string;
}

/// Trait for the configuration of various expected counters in the data.
pub trait CustomChecksOpt {
    /// Returns if any custom checks are enabled.
    fn custom_checks_enabled(&self) -> bool {
        self.cdps().is_some() || self.triggers_pht().is_some()
    }

    /// Returns if the option to generate a TOML file with default custom checks is enabled.
    fn generate_custom_checks_toml_enabled(&self) -> bool;

    /// Get the custom checks from a TOML file returning a [CustomChecks] instance.
    fn custom_checks_from_path(&self, toml_path: &PathBuf) -> CustomChecks {
        let toml = std::fs::read_to_string(toml_path).expect("Failed to read TOML file");
        toml::from_str(&toml).expect("Failed to parse TOML")
    }

    /// Write a [CustomChecks] instance to a TOML file in the current directory.
    fn generate_custom_checks_toml(&self) {
        let toml = CustomChecks::default().to_string_pretty_toml();
        std::fs::write("custom_checks.toml", toml).expect("Failed to write TOML file");
    }

    /// Get the number of CDPs expected in the data, if it is set.
    fn cdps(&self) -> Option<u32>;

    /// Get the number of sent Triggers expected in the data, if it is set.
    fn triggers_pht(&self) -> Option<u32>;
}

impl<T> CustomChecksOpt for &T
where
    T: CustomChecksOpt,
{
    fn custom_checks_enabled(&self) -> bool {
        (*self).custom_checks_enabled()
    }

    fn generate_custom_checks_toml_enabled(&self) -> bool {
        (*self).generate_custom_checks_toml_enabled()
    }

    fn cdps(&self) -> Option<u32> {
        (*self).cdps()
    }

    fn triggers_pht(&self) -> Option<u32> {
        (*self).triggers_pht()
    }
}

impl<T> CustomChecksOpt for Box<T>
where
    T: CustomChecksOpt,
{
    fn custom_checks_enabled(&self) -> bool {
        (**self).custom_checks_enabled()
    }

    fn generate_custom_checks_toml_enabled(&self) -> bool {
        (**self).generate_custom_checks_toml_enabled()
    }

    fn cdps(&self) -> Option<u32> {
        (**self).cdps()
    }

    fn triggers_pht(&self) -> Option<u32> {
        (**self).triggers_pht()
    }
}

impl<T> CustomChecksOpt for std::sync::Arc<T>
where
    T: CustomChecksOpt,
{
    fn custom_checks_enabled(&self) -> bool {
        (**self).custom_checks_enabled()
    }

    fn generate_custom_checks_toml_enabled(&self) -> bool {
        (**self).generate_custom_checks_toml_enabled()
    }

    fn cdps(&self) -> Option<u32> {
        (**self).cdps()
    }

    fn triggers_pht(&self) -> Option<u32> {
        (**self).triggers_pht()
    }
}

/// Struct for the configuration of various expected counters in the data.
#[derive(TomlConfig, Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct CustomChecks {
    #[description = "Number of CRU Data Packets expected in the data"]
    #[example = "20, 500532"]
    cdps: Option<u32>,
    #[description = "Number of Physics (PhT) Triggers expected in the data"]
    #[example = "0, 10"]
    triggers_pht: Option<u32>,
}

impl CustomChecks {
    /// Get the number of CDPS expected in the data, if it is set.
    pub fn cdps(&self) -> Option<u32> {
        self.cdps
    }

    /// Get the number of sent Triggers expected in the data, if it is set.
    pub fn triggers_pht(&self) -> Option<u32> {
        self.triggers_pht
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use pretty_assertions::assert_eq;
    use temp_dir::TempDir;

    #[test]
    fn test_serialize_custom_checks() {
        let custom_checks = CustomChecks::default();
        let custom_checks_toml = custom_checks.to_string_pretty_toml();
        println!(
            "==== TOML ====\n{}\n==== End of TOML ====",
            custom_checks_toml
        );
        assert_eq!(
            custom_checks_toml,
            r#"# Number of CRU Data Packets expected in the data
# Example: 20, 500532
#cdps = None [ u32 ] # (Uncomment and set to enable this check)

# Number of Physics (PhT) Triggers expected in the data
# Example: 0, 10
#triggers_pht = None [ u32 ] # (Uncomment and set to enable this check)

"#
        );
    }

    #[test]
    fn test_deserialize_counters_default() {
        let custom_checks_toml = r#"
# Number of CRU Data Packets expected in the data
# Example: 20, 500532
#cdps = None [ u32 ] # (Uncomment and set to enable this check)

# Number of Physics (PhT) Triggers expected in the data
# Example: 0, 10
#triggers_pht = None [ u32 ] # (Uncomment and set to enable this check)
"#;
        let custom_checks: CustomChecks = toml::from_str(custom_checks_toml).unwrap();
        assert_eq!(custom_checks, CustomChecks::default());
    }

    #[test]
    fn test_deserialize_counters_some_values() {
        let counters_toml = r#"
# Number of CRU Data Packets expected in the data
# Example: 20, 500532
cdps = 10 # (Uncomment and set to enable this check)

# Number of Physics (PhT) Triggers expected in the data
# Example: 0, 10
triggers_pht = 0 # (Uncomment and set to enable this check)
"#;
        let counters: CustomChecks = toml::from_str(counters_toml).unwrap();
        assert_eq!(
            counters,
            CustomChecks {
                cdps: Some(10),
                triggers_pht: Some(0),
            }
        );
    }

    #[test]
    fn test_write_toml_to_file() {
        let counters = CustomChecks::default();
        let toml = counters.to_string_pretty_toml();

        let tmp_dir = TempDir::new().unwrap();
        let toml_file = tmp_dir.child("counters.toml");
        std::fs::write(&toml_file, &toml).unwrap();

        assert_eq!(std::fs::read_to_string(toml_file).unwrap(), toml);
    }

    #[test]
    fn test_read_toml_from_file() {
        let counters = CustomChecks::default();
        let toml = counters.to_string_pretty_toml();
        println!("toml string:\n{toml}");
        let tmp_dir = TempDir::new().unwrap();
        let toml_file = tmp_dir.child("counters.toml");
        std::fs::write(&toml_file, &toml).unwrap();
        let toml = std::fs::read_to_string(toml_file).expect("Failed to read TOML file");
        let custom_checks_from_toml: CustomChecks =
            toml::from_str(&toml).expect("Failed to parse TOML");

        println!("Struct from toml file: {:?}", custom_checks_from_toml);
        assert_eq!(custom_checks_from_toml.cdps(), None);
        assert_eq!(custom_checks_from_toml.triggers_pht(), None);
    }

    #[test]
    fn test_write_toml_to_file_trait() {
        let mock_config = crate::util::lib::test_util::MockConfig::default();
        mock_config.generate_custom_checks_toml();
        // Cleanup
        std::fs::remove_file("custom_checks.toml").unwrap();
    }
}
