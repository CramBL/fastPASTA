image: "rust:latest"

default:
  before_script:
    - hostname -I
    - whoami
    - rustc --version
    - cargo --version

# Setup a cache to cache job parts between jobs to ensure faster builds
cache:
  - key: "$CI_JOB_NAME"
    untracked: true
    paths:
      - $CI_PROJECT_DIR/target/

# Set any required environment variables here
variables:
  RUST_BACKTRACE: "FULL"

stages:
  - code-quality
  - build
  - test
  - release

### Code quality ###
# * pre-commit
# * lint
# * format
# * audit
pre-commit:
  image: python:3.9
  stage: code-quality
  before_script:
    - pip install pre-commit
  script:
    - python3 --version
    - pre-commit --version
    - pre-commit run --all-files --show-diff-on-failure

lint:
  stage: code-quality
  script:
    - rustup component add clippy
    - cargo check
    - cargo clean
    - cargo clippy -- -D warnings --no-deps

format:
  stage: code-quality
  script:
    - ls
    - echo "checking if Cargo.toml version matches lates git tag"
    - git --version
    - git fetch --tags
    - git tag
    - echo "Comparing the following two commands"
    - cat Cargo.toml | grep -Po "(?<=^version = \").*(?=\")"
    - git tag --list | grep -Po "(?<=v).*" | tail -1
    - echo "if this steps fails, update the Cargo.toml version number with the one from the newest git tag"
    - tagdiff=$(diff <(git tag --list | grep -Po "(?<=v).*" | tail -1) <(cat Cargo.toml | grep -Po "(?<=^version = \").*(?=\")") | wc -l | grep "[0-9]")
    - if [ "$tagdiff" -eq 0 ]; then echo "version numbers match";
    - fi
    - printf "Git tag and project version match, now doing basic syntax check to confirm that code compiles\n"
    - rustup component add rustfmt
    - cargo fmt -- --check
    - echo "checking if documentation builts"
    - cargo doc

audit:
  stage: code-quality
  script:
    - cargo install cargo-audit
    - cargo audit
### end of stage: code-quality

### build ###

# Build a binary with debug enabled if pushed to master branch
rust-latest:
  stage: build
  script:
    - cargo build --verbose
  rules:
    - if: '$CI_COMMIT_BRANCH == "master"'
  artifacts:
    name: "debug_${CI_COMMIT_SHA}"
    paths:
    - ./target
    expire_in: 2 weeks

# Build a binary with nightly rust for later jobs
rust-nightly-build:
  stage: build
  image: rustlang/rust:nightly
  script:
    - cargo build --verbose
  allow_failure: true
  artifacts:
    paths:
      - $CI_PROJECT_DIR/target/
    untracked: true
    when: on_success
    expire_in: 50 mins
  cache: []

# build latest rust with instrument coverage for the test coverage job
rust-latest-build:
  stage: build
  script:
    - cargo build --verbose
  artifacts:
    paths:
      - $CI_PROJECT_DIR/target/
    untracked: true
    when: on_success
    expire_in: 50 mins

## Regression tests
regression-tests:
  stage: build
  before_script:
    - ls -l tests/regression/
  script:
    - cargo build
    - tests/regression/regression_tests.sh
  dependencies:
    - rust-latest-build

### Tests and safety ###
# Run unit tests with nightly build
rust-nightly-test:
  stage: test
  image: rustlang/rust:nightly
  script:
    - cargo test --verbose -- --test-threads=1 --nocapture
  allow_failure: true
  dependencies:
    - rust-nightly-build
  cache: []

# Run tests and calculate code coverage
test-coverage:
  stage: test
  variables:
    RUSTFLAGS: "-C instrument-coverage"
    LLVM_PROFILE_FILE: "target/coverage/%p-%m.profraw"
  script:
    - echo "${LLVM_PROFILE_FILE}"
    - echo "${RUSTFLAGS}"
    - rustup component add llvm-tools-preview
    - cargo install grcov
    - apt-get update && apt-get install -y lcov
    - cargo build
    # Rust-based tests
    - cargo test -- --test-threads=1 --nocapture
    - mkdir -p target/coverage
    - ls -l target/coverage
    - grcov target/coverage --binary-path target/debug -s . --output-types html,cobertura,lcov --branch --ignore-not-existing --ignore '../*' --ignore "/*" --ignore "$HOME/.cargo/**" --ignore "*cargo*" -o target/coverage --keep-only 'src/*'
    - echo "Coverage files generated"
    - ls -l target/coverage
    - lcov --summary coverage.lcov
  coverage: /lines\.*:\s*([\d\.]+%)/
  dependencies: []
  artifacts:
    paths:
      - target/coverage/
    reports:
      coverage_report:
        coverage_format: cobertura
        path: target/coverage/cobertura.xml


## Safety
# Only includes address and leak sanitizing now, as there's simply too many false positives with memory and thread sanitizing on Rust code...
# Leak and address sanitizing is also bugged (see links below) but there's decent work arounds at the moment
leak-sanitizer:
  stage: test
  image: rustlang/rust:nightly
  variables:
    LSAN_OPTIONS: "suppressions=lsan-suppressions.txt"
    RUSTFLAGS: "-Z sanitizer=leak"
  script:
    - rustup component add llvm-tools-preview
    # to fix buggy leak analyzer:
    # https://github.com/japaric/rust-san#unrealiable-leaksanitizer
    - sed -i '/\[features\]/i [profile.dev]' Cargo.toml
    - sed -i '/profile.dev/a opt-level = 1' Cargo.toml
    - cat Cargo.toml
    - rustup component add rust-src --toolchain nightly-x86_64-unknown-linux-gnu
    - cargo build -Z build-std --target x86_64-unknown-linux-gnu --verbose
    - cargo test --verbose --lib --tests --all-features --target x86_64-unknown-linux-gnu -- --test-threads=1 --nocapture
  allow_failure: true
  dependencies: []
  cache: []

address-sanitizer:
  stage: test
  image: rustlang/rust:nightly
  variables:
    ASAN_OPTIONS: "detect_odr_violation=0:detect_leaks=0"
    RUSTFLAGS: "-Z sanitizer=address"
  script:
    - rustup component add llvm-tools-preview
    - rustup component add rust-src --toolchain nightly-x86_64-unknown-linux-gnu
    - cargo build -Z build-std --target x86_64-unknown-linux-gnu --verbose
    # only --lib --tests b/c of https://github.com/rust-lang/rust/issues/53945
    - cargo test --verbose --lib --tests --all-features --target x86_64-unknown-linux-gnu -- --test-threads=1 --nocapture
  allow_failure: true
  dependencies: []
  cache: []

# Job for building docs and publishing to Gitlab Pages
pages:
  stage: build
  script:
    - cargo doc
    - rm -rf public
    - mkdir public
    - cp -R target/doc/* public
  artifacts:
    paths:
      # The folder that contains the files to be exposed at the Page URL
      - public
  rules:
    # This ensures that only pushes to the default branch will trigger
    # a pages deploy
    - if: $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH

## For release build
build-release-latest:
  stage: release
  rules:
    - if: $CI_COMMIT_TAG  # Run this job when a tag is created
  script:
    - echo "Running release job"
    - echo "Testing release build profile"
    - cargo build -r --verbose
    - echo "Publishing has to be done manually :)"
