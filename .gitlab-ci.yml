image: "rust:latest"

default:
  before_script:
    - hostname -I
    - whoami
    - rustc --version
    - cargo --version

# Setup a cache to cache job parts between jobs to ensure faster builds
cache:
  - key: "$CI_JOB_NAME"
    untracked: true
    paths:
      - $CI_PROJECT_DIR/target/

# Set any required environment variables here
variables:
  RUST_BACKTRACE: "FULL"

stages:
  - code-quality
  - build-and-test
  - test-safety
  - release

pre-commit:
  image: python:3.9
  stage: code-quality
  before_script:
    - pip install pre-commit
  script:
    - python3 --version
    - pre-commit --version
    - pre-commit run --all-files --show-diff-on-failure

lint:
  stage: code-quality
  script:
    - rustup component add clippy
    - cargo check
    - cargo clean
    - cargo clippy -- -D warnings --no-deps

format:
  stage: code-quality
  script:
    - echo "checking if Cargo.toml version matches lates git tag"
    - echo "if this steps fails, update the Cargo.toml version number with the one from the newest git tag"
    - tagdiff=$(diff <(git tag --list | grep -Po "(?<=v).*" | tail -1) <(cat Cargo.toml | grep -Po "(?<=^version = \").*(?=\")") | wc -l | grep "[0-9]")
    - if [ "$tagdiff" -eq 0 ]; then echo "version numbers match";
    - fi
    - rustup component add rustfmt
    - cargo fmt -- --check

audit:
  stage: code-quality
  script:
    - cargo install cargo-audit
    - cargo audit

rust-latest:
  stage: build-and-test
  image: rust:latest
  script:
    - cargo build --verbose
  rules:
    - if: '$CI_COMMIT_BRANCH == "master"'
  artifacts:
    name: "debug_${CI_COMMIT_SHA}"
    paths:
    - ./target
    expire_in: 1 mos

rust-nightly:
  stage: build-and-test
  image: rustlang/rust:nightly
  script:
    - cargo build --verbose
    - cargo test --verbose -- --test-threads=1 --nocapture
  allow_failure: true

test-coverage:
  image: rust:latest
  stage: build-and-test
  variables:
    RUSTFLAGS: "-C instrument-coverage"
    LLVM_PROFILE_FILE: "coverage-%p-%m.profraw"
  script:
    - rustup component add llvm-tools-preview
    - cargo build
    - cargo test -- --test-threads=1 --nocapture
    - cargo install grcov
    # Generate HTML report which is available as an artifact
    - grcov . --binary-path ./target/debug/ -s . -t html --branch --ignore-not-existing --ignore "*cargo*" -o ./coverage/
    # Generate file for Gitlab coverage parsing (through the summary)
    - grcov . --binary-path ./target/debug/ -s . -t lcov --branch --ignore-not-existing --ignore "*cargo*" -o coverage.lcov
    # directly generate cobertura file
    - grcov . --binary-path ./target/debug/ -s . -t cobertura --branch --ignore-not-existing --ignore "*cargo*" -o coverage.xml
    # Output coverage for Gitlab parser (uses regex in coverage key)
    - apt-get update && apt-get install -y lcov
    - lcov --summary coverage.lcov
  coverage: /lines\.*:\s*([\d\.]+%)/
  artifacts:
    paths:
      - 'coverage'
    expire_in: 3 mos
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml

## Regression tests
regression-tests:
  image: rust:latest
  stage: build-and-test
  before_script:
    - |
      test_cmds="test-data/tests.txt"
      IFS=$'\n' read -d '' -r -a cmd_list < $test_cmds
      TXT_RED="\e[31m";
      TXT_YELLOW="\e[33m";
      TXT_BRIGHT_YELLOW="\e[93m";
      TXT_BRIGHT_CYAN="\e[96m";
      TXT_CLEAR="\e[0m";
      ig="egrep -i" # Case insensitive egrep
      all_test_passed="echo all test passed!";
    - cargo build
    - test_1="cargo run -- ./test-data/readout.superpage.1.raw check all its -v2"
    - pattern_1="Data Format.*2|((INFO -).*((EOF)|(Exit Successful))*)"
    - test_2="cargo run -- ./test-data/readout.superpage.1.raw check sanity its"
    - pattern_2="Data Format.*2";
    - | # Test on 10_rdh.raw
      test_3a="cargo run -- ./test-data/10_rdh.raw check sanity"
      pattern_3a="RDHs.*Version.*7"
      match_3a="${ig} '${pattern_3a}'"
      cond_3a="-eq 1"
      pattern_3b="Total.*RDHs.*10"
      match_3b="$ig '{pattern_3b}'"
      cond_3a="-eq 1"


  script:
    - |
      echo -e "running test ${TXT_BRIGHT_YELLOW}$test_1${TXT_CLEAR}";
      echo -e "3 lines should match ${TXT_BRIGHT_CYAN}$pattern_1";
      test_out=$(eval "$test_1" 2>&1);
      pattern_1_match=$(echo "$test_out" | egrep "$pattern_1" | wc -l)
    - if [[ "$pattern_1_match" -ne 3 ]]; then echo -e "${TXT_RED}Test failed${TXT_CLEAR} $test_1"; all_test_passed="exit 1"; fi;
    - |
      echo -e "running test ${TXT_BRIGHT_YELLOW}$test_2${TXT_CLEAR}";
      echo -e "1 line should match ${TXT_BRIGHT_CYAN}$pattern_2";
      test_out=$(eval "$test_2" 2>&1);
      pattern_2_match=$(echo "$test_out" | egrep "$pattern_2" | wc -l)
    - if [[ "$pattern_2_match" -ne 1 ]]; then echo -e "${TXT_RED}Test failed${TXT_CLEAR} $test_2"; all_test_passed="exit 1"; fi;
    - |
      echo -e "running test ${TXT_BRIGHT_YELLOW}$test_2${TXT_CLEAR}";
      echo -e "1 line should match ${TXT_BRIGHT_CYAN}$pattern_3a";
      test_out=$(eval "$test_3a" 2>&1);
      pattern_3a_match=$(echo "$test_out" | $match_3a | wc -l)
    - if [[ "$pattern_3a_match" $"cond_3a" ]]; then echo -e "${TXT_RED}Test failed${TXT_CLEAR} $test_3a"; all_test_passed="exit 1"; fi;
    - |
      for (( i=0; i<${#cmd_list[@]}; i+=3 )); do test=${cmd_list[i]}; pattern=${cmd_list[i+1]}; cond=${cmd_list[i+2]};
      echo "Executing commands: $cmd1, $cmd2, $cmd3";
      echo -e "running test ${TXT_BRIGHT_YELLOW}$test${TXT_CLEAR}";
      echo -e "Condition: ${TXT_BRIGHT_YELLOW}${cond}${TXT_CLEAR} for ${TXT_BRIGHT_CYAN}$pattern";
      test_out=$(eval $test 2>&1);
      matches=$(echo $"test_out" | egrep -i '${pattern}' | wc -l)
      if [[ "$matches" "$cond" ]]; then echo -e "${TXT_RED}Test failed${TXT_CLEAR} $test"; all_test_passed="exit 1"; fi;
      done
    - eval "$all_test_passed"

## For release build
build-release-latest:
  stage: release
  rules:
    - if: $CI_COMMIT_TAG  # Run this job when a tag is created
  image: rust:latest
  script:
    - echo "running release job"
    - cargo build -r --verbose
  artifacts:
    name: "release_${CI_COMMIT_TAG}"
    paths:
    - ./target

## Safety
# Only includes address and leak sanitizing now, as there's simply too many false positives with memory and thread sanitizing on Rust code...
# Leak and address sanitizing is also bugged (see links below) but there's decent work arounds at the moment
leak-sanitizer:
  stage: test-safety
  image: rustlang/rust:nightly
  variables:
    LSAN_OPTIONS: "suppressions=lsan-suppressions.txt"
    RUSTFLAGS: "-Z sanitizer=leak"
  script:
    - rustup component add llvm-tools-preview
    # to fix buggy leak analyzer:
    # https://github.com/japaric/rust-san#unrealiable-leaksanitizer
    - sed -i '/\[features\]/i [profile.dev]' Cargo.toml
    - sed -i '/profile.dev/a opt-level = 1' Cargo.toml
    - cat Cargo.toml
    - rustup component add rust-src --toolchain nightly-x86_64-unknown-linux-gnu
    - cargo build -Z build-std --target x86_64-unknown-linux-gnu --verbose
    - cargo test --verbose --lib --tests --all-features --target x86_64-unknown-linux-gnu -- --test-threads=1 --nocapture
  allow_failure: true

address-sanitizer:
  stage: test-safety
  image: rustlang/rust:nightly
  variables:
    ASAN_OPTIONS: "detect_odr_violation=0:detect_leaks=0"
    RUSTFLAGS: "-Z sanitizer=address"
  script:
    - rustup component add llvm-tools-preview
    - rustup component add rust-src --toolchain nightly-x86_64-unknown-linux-gnu
    - cargo build -Z build-std --target x86_64-unknown-linux-gnu --verbose
    # only --lib --tests b/c of https://github.com/rust-lang/rust/issues/53945
    - cargo test --verbose --lib --tests --all-features --target x86_64-unknown-linux-gnu -- --test-threads=1 --nocapture
  allow_failure: true

# Job for building docs and publishing to Gitlab Pages
pages:
  stage: build-and-test
  script:
    - cargo doc
    - rm -rf public
    - mkdir public
    - cp -R target/doc/* public
  artifacts:
    paths:
      # The folder that contains the files to be exposed at the Page URL
      - public
  rules:
    # This ensures that only pushes to the default branch will trigger
    # a pages deploy
    - if: $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH
